{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"1. Concept of Operating Systems","text":""},{"location":"#software-and-hardware-definitions","title":"Software and Hardware Definitions","text":"<ul> <li>Program: A program is defined as a collection of code or instructions.</li> <li>Software: Software is a collection of programs.</li> <li>Hardware: This refers to the physical devices that make up a computer system.</li> <li>Examples of Hardware: Key components include the Processor, RAM, Hard disk, and various $I/O$ devices.</li> </ul>"},{"location":"#types-of-software","title":"Types of Software","text":"<p>Software is categorized into three primary types:</p>"},{"location":"#1-system-software","title":"1. System Software","text":"<ul> <li>This software is used to perform all types of system-level tasks for the computer.</li> <li>Examples: Operating systems, Compilers, Interpreters, Linkers, and Loaders.</li> </ul>"},{"location":"#2-utility-software","title":"2. Utility Software","text":"<ul> <li>This software provides additional functionality or \"meaning\" to the computer system.</li> <li>Examples: Calculators, MS-Paint, Web Browsers, Notepads, and Media Players.</li> </ul>"},{"location":"#3-application-software","title":"3. Application Software","text":"<ul> <li>These are created by users using different high-level languages and database systems for specific purposes.</li> <li>Examples: Library Management Systems, Banking Software, and Ticket Reservation systems.</li> </ul>"},{"location":"#definition-of-operating-system","title":"Definition of Operating System","text":"<p>An Operating System (OS) can be defined in two primary ways:</p> <ul> <li>As a Manager: It is a collection of system software that manages computer hardware resources and provides common services for computer programs.</li> <li>As an Interface: It acts as an intermediary or interface between a user of a computer and the computer hardware.</li> <li>Users and processes access the computer's physical resources (Hardware) exclusively through the Operating System.</li> </ul>"},{"location":"#operating-system-goals","title":"Operating System Goals","text":"<p>The primary objectives of an operating system include:</p> <ul> <li>User Convenience: To simplify the execution of user programs and make solving user problems easier.</li> <li>Efficiency: To ensure that the computer hardware is used efficiently.</li> <li>Resource Sharing: To allow the sharing of both hardware and software resources among different users or programs.</li> <li>Portability: To make application software portable and flexible.</li> <li>Security: To provide isolation, security, and protection among various user programs.</li> <li>Reliability: To improve overall system reliability through features like error confinement, fault tolerance, and reconfiguration.</li> </ul>"},{"location":"#2-generations-of-operating-systems","title":"2. Generations of Operating Systems","text":"<p>The history of operating systems is divided into four distinct generations.</p>"},{"location":"#first-generation-19451955","title":"First Generation (1945\u20131955)","text":"<p>Vacuum Tubes and Plugboards * Digital computers were not constructed until World War II.</p> <ul> <li>Early calculating engines used mechanical relays, which were very slow.</li> <li>Mechanical relays were eventually replaced by vacuum tubes.</li> <li>These machines were enormous in size but remained very slow in operation.</li> </ul> <p>Machine Language and Numerical Calculations * There were no operating systems during this period, and programming languages were unknown.</p> <ul> <li>All programming was performed directly in machine language.</li> <li>Problems solved were almost exclusively simple numerical calculations.</li> <li>In the 1950s, punch cards were introduced, allowing programs to be read into the system instead of using plugboards.</li> </ul>"},{"location":"#second-generation-19551965","title":"Second Generation (1955\u20131965)","text":"<p>Transistors and Batch Systems * The introduction of transistors allowed for the manufacturing of computers that could be sold to customers.</p> <ul> <li>To reduce wasted time in computer operations, the Batch System was introduced.</li> </ul> <p>Mainframes and Magnetic Tape * These computers were known as mainframes and were kept in locked, air-conditioned rooms operated by specialized staff.</p> <ul> <li>In a batch system, a tray of jobs was collected in an input room and read onto magnetic tape.</li> </ul>"},{"location":"#third-generation-19651980","title":"Third Generation (1965\u20131980)","text":"<p>Integrated Circuits and Multiprogramming * This generation utilized Integrated Circuits (ICs), providing major price and performance advantages.</p> <ul> <li>Operating systems introduced Multiprogramming, which ensured the processor did not remain idle while a job completed I/O operations.</li> <li>When one job was waiting, another job was scheduled on the processor so time was not wasted.</li> </ul> <p>IBM System/360 * IBM combined scientific and commercial computer systems into the System/360.</p>"},{"location":"#fourth-generation-1980present","title":"Fourth Generation (1980\u2013Present)","text":"<p>Personal Computers and LSI Circuits * The development of Large-Scale Integrated (LSI) circuits\u2014chips containing thousands of transistors on a square centimeter of silicon\u2014made Personal Computers easy to create.</p> <p>Network and Distributed Operating Systems * The advent of PCs led to the growth of networks, creating Network Operating Systems and Distributed Operating Systems.</p> <ul> <li>In a network OS, users are aware of the network and can log in to remote machines or copy files between them.</li> </ul> <p>Examples: Windows, Mac OS, and Linux * Microsoft Windows: Created in the mid-1980s. Versions include Windows Vista, 7, 8, and 10. It is the most popular OS as it comes pre-loaded on most PCs.</p> <ul> <li>Mac OS: A line of operating systems created by Apple that comes preloaded on Macintosh computers. Versions include Lion, Mountain Lion, Mavericks, Yosemite, and El Capitan.</li> <li>Linux: A family of open-source operating systems that can be modified and distributed by anyone. It is free and available in many different distributions.</li> </ul> <p>Mobile Device Operating Systems * Mobile devices (smartphones, tablets) run operating systems specifically designed for them, as they differ from desktop/laptop hardware.</p> <ul> <li>Examples: Apple iOS and Google Android.</li> </ul>"},{"location":"#3-types-of-operating-systems","title":"3. Types of Operating Systems","text":""},{"location":"#simple-batch-system","title":"Simple Batch System","text":"<ul> <li>Lack of Interaction: There is no direct interaction between the user and the computer.</li> <li>Job Submission: The user submits a job, written on cards or tape, to a computer operator.</li> <li>Batch Processing: The operator places a batch of several jobs on an input device for processing.</li> <li>Advantages: It increases performance as the next job starts immediately after the previous one finishes, making it suitable for large jobs with little interaction.</li> <li>Disadvantages: There is zero interaction and no mechanism to prioritize processes.</li> </ul>"},{"location":"#multiprogramming-batch-system","title":"Multiprogramming Batch System","text":"<ul> <li>CPU Multiplexing: Several jobs are kept in main memory at the same time, and the CPU is multiplexed among them.</li> <li>CPU Utilization: This system increases CPU utilization because the CPU is always executing some program instead of waiting for I/O operations.</li> <li>Memory Layout: Multiple jobs are loaded into main memory, and one is selected from the pool for execution.</li> <li>Job Scheduling: If a program in progress requires I/O service, control of the CPU is given to the next job in main memory.</li> <li>Efficiency Comparison: Multiprogramming significantly improves throughput (e.g., $12~jobs/hr$ vs $6~jobs/hr$ in uniprogramming) and reduces mean response time.</li> </ul>"},{"location":"#effects-of-multiprogramming-the-comparison","title":"Effects of Multiprogramming (The Comparison)","text":"<p>The following table demonstrates why multiprogramming is more efficient than uniprogramming:</p> Metric Uniprogramming Multiprogramming Processor use 17% 33% Memory use 30% 67% Disk use 33% 67% Printer use 33% 67% Elapsed time 30 min. 15 min. Throughput rate 6\u00a0jobs/hr 12\u00a0jobs/hr Mean response time 18 min. 10 min."},{"location":"#multitasking-time-sharing-system-tss","title":"Multitasking / Time-Sharing System (TSS)","text":"<ul> <li>Interactive Jobs: TSS extends multiprogramming to handle multiple interactive jobs, providing the impression that the entire computer is dedicated to a single user.</li> <li>Time-Slices: Each user is given a specific time-slice for executing their job.</li> <li>Round-Robin Fashion: Processes are given equal amounts of CPU time one by one in a sequence.</li> <li>Context Switches: The system allows frequent context switches from one user to the next when a time-slice ends.</li> <li>Advantages: It provides quick response times and reduces CPU idle time.</li> </ul>"},{"location":"#multiprocessor-parallel-system","title":"Multiprocessor / Parallel System","text":"<ul> <li>Tightly Coupled Systems: These systems feature more than one CPU working in close communication, sharing memory, I/O devices, buses, and power supplies.</li> <li>Shared Memory: Communication between processors usually takes place through shared memory.</li> <li>Computing Power: It delivers higher computing power and speed under a single operating system.</li> <li>Reliability: Failure of one processor will not stop the system; it continues to function with the remaining processors.</li> <li>Economy: It is cheaper to buy one system with multiple CPUs than multiple systems with single CPUs.</li> </ul>"},{"location":"#real-time-system","title":"Real-Time System","text":"<ul> <li>Time Constraints: A Real-Time Operating System (RTOS) guarantees capabilities within specified time constraints.</li> <li>Hard Real-Time:<ul> <li>It guarantees that critical operations complete on time.</li> <li>If the system fails to meet a deadline even once, the entire system is considered to have failed.</li> <li>Examples include defense applications and nuclear systems where missing deadlines creates hazards.</li> </ul> </li> <li>Soft Real-Time:<ul> <li>Critical tasks get priority, but there is no absolute assurance of completion within a defined time.</li> <li>Failing a deadline does not mean the system has failed, and results are still useful.</li> <li>Examples include audio-video streaming.</li> </ul> </li> </ul>"},{"location":"#distributed-system","title":"Distributed System","text":"<ul> <li>Loosely Coupled Systems: Each processor has its own local memory, and they do not share a clock.</li> <li>Load Sharing: Computation is distributed among several physical processors to speed up processing and shorten response times.</li> <li>Communication Networks: Processors communicate via various lines such as high-speed buses or telephone lines using a protocol.</li> <li>Advantages: Includes resource sharing, incremental growth by adding resources, and higher reliability due to tolerance against failure.</li> </ul>"},{"location":"#4-operating-system-services","title":"4. Operating System Services","text":"<p>The operating system provides an environment for the execution of programs and services to the users of those programs.</p>"},{"location":"#user-interface-ui","title":"User Interface (UI)","text":"<ul> <li>Almost all operating systems have a user interface.</li> <li>Command-Line Interface (CLI): Uses text commands and a method for entering them.</li> <li>Graphics User Interface (GUI): A window system with a pointing device to direct I/O, choose from menus, and make selections.</li> <li>Batch Interface: Commands and directives to control those commands are entered into files, and those files are executed.</li> </ul>"},{"location":"#program-execution","title":"Program Execution","text":"<ul> <li>The system must be able to load a program into memory and run that program.</li> <li>It must be able to end execution, either normally or abnormally (indicating an error).</li> </ul>"},{"location":"#io-operations","title":"I/O Operations","text":"<ul> <li>A running program may require I/O, which may involve a file or an I/O device.</li> <li>Because user programs cannot execute I/O operations directly, the operating system must provide a means to do so.</li> </ul>"},{"location":"#file-system-manipulation","title":"File-System Manipulation","text":"<ul> <li>Programs need to read and write files and directories.</li> <li>The OS handles creating and deleting files, searching them, listing file information, and permission management.</li> <li>It allows or denies access to files or directories based on file ownership.</li> </ul>"},{"location":"#communications","title":"Communications","text":"<ul> <li>The OS facilitates the exchange of information between processes.</li> <li>Communications may occur between processes executing on the same computer or on different systems tied together by a network.</li> <li>This is implemented via shared memory or message passing.</li> </ul>"},{"location":"#error-detection","title":"Error Detection","text":"<ul> <li>The OS needs to be constantly aware of possible errors.</li> <li>Errors may occur in the CPU and memory hardware, in I/O devices, or in user programs.</li> <li>For each type of error, the OS should take appropriate action to ensure correct and consistent computing.</li> </ul>"},{"location":"#additional-os-services","title":"Additional OS Services","text":"<p>These services exist for ensuring the efficient operation of the system itself rather than for the user.</p>"},{"location":"#resource-allocation","title":"Resource Allocation","text":"<ul> <li>When multiple users or jobs are running concurrently, resources (such as CPU cycles, main memory, and file storage) must be allocated to each of them.</li> </ul>"},{"location":"#accounting","title":"Accounting","text":"<ul> <li>The OS keeps track of which users use how much and what kinds of computer resources.</li> <li>This data is used for accounting or usage statistics.</li> </ul>"},{"location":"#protection-and-security","title":"Protection and Security","text":"<ul> <li>Protection: Involves ensuring that all access to system resources is controlled.</li> <li>Security: Defends the system against outsiders through user authentication (passwords) and protects external I/O devices from invalid access attempts.</li> <li>The system ensures that concurrent processes do not interfere with each other.</li> </ul>"},{"location":"#5-system-calls","title":"5. System Calls","text":"<p>A system call is a request made by a user program in order to get the service of an operating system. When a program in user mode requires access to RAM or a hardware resource, it must ask the kernel to provide access via a system call.</p>"},{"location":"#user-mode-vs-kernel-mode","title":"User Mode vs. Kernel Mode","text":"<p>The CPU operates in two distinct modes to ensure system security and stability:</p> <ul> <li>Kernel Mode:<ul> <li>This is a highly privileged and powerful mode.</li> <li>The code being executed can access any memory address and any hardware resource.</li> <li>If a program crashes in kernel mode, the entire system will be halted.</li> </ul> </li> <li>User Mode:<ul> <li>Programs do not have direct access to memory and hardware resources.</li> <li>If a program crashes in user mode, only that particular program is halted, leaving the rest of the system in a safe state.</li> <li>Most applications run in this mode to protect the system.</li> </ul> </li> </ul>"},{"location":"#process-management-system-calls","title":"Process Management System Calls","text":"<p>These calls are used to control the lifecycle of processes.</p> <ul> <li>$pid=fork()$: Creates a child process that is identical to the parent.</li> <li>$pid=waitpid(pid, \\&amp;statloc, options)$: Used by a parent process to wait for a child to terminate.</li> <li>$s=execve(name, argv, environp)$: Replaces a process's core image with a new program.</li> <li>$exit(status)$: Terminates process execution and returns a status code.</li> </ul>"},{"location":"#file-management-system-calls","title":"File Management System Calls","text":"<p>These calls handle individual file operations.</p> <ul> <li>$fd=open(file, how, ...)$: Opens a file for reading, writing, or both.</li> <li>$s=close(fd)$: Closes an currently open file.</li> <li>$n=read(fd, buffer, nbytes)$: Reads data from a file into a buffer.</li> <li>$n=write(fd, buffer, nbytes)$: Writes data from a buffer into a file.</li> <li>$position=lseek(fd, offset, whence)$: Moves the file pointer to a specific location.</li> <li>$s=stat(name, \\&amp;buf)$: Retrieves status information about a file.</li> </ul>"},{"location":"#directory-management-system-calls","title":"Directory Management System Calls","text":"<p>These calls are used for managing the file system structure.</p> <ul> <li>$s=mkdir(name, mode)$: Creates a new directory.</li> <li>$s=rmdir(name)$: Removes an empty directory.</li> <li>$s=link(name1, name2)$: Creates a new directory entry (name2) pointing to an existing file (name1).</li> <li>$s=unlink(name)$: Removes a directory entry.</li> <li>$s=mount(special, name, flag)$: Mounts a file system onto the directory tree.</li> <li>$s=umount(special)$: Unmounts a previously mounted file system.</li> </ul>"},{"location":"#miscellaneous-system-calls","title":"Miscellaneous System Calls","text":"<p>These calls handle various system tasks and file protections.</p> <ul> <li>$s=chdir(dirname)$: Changes the current working directory.</li> <li>$s=chmod(name, mode)$: Changes a file's protection bits (permissions).</li> <li>$s=kill(pid, signal)$: Sends a signal to a process, often used to terminate it.</li> <li>$seconds=time(\\&amp;seconds)$: Gets the elapsed time (in seconds) since January 1, 1970.</li> </ul>"},{"location":"#6-structure-of-an-operating-system","title":"6. Structure of an Operating System","text":"<p>The structure of an OS determines how the various software components are organized and how they interact with the hardware.</p>"},{"location":"#layered-structure","title":"Layered Structure","text":"<p>In the layered approach, the operating system is broken into a number of layers (levels).</p> <ul> <li>Hierarchy from Hardware to UI: The bottom layer (Layer 0) is the hardware, and the highest layer (Layer N) is the user interface.</li> <li>Encapsulation: Each layer uses functions and services of only lower-level layers.</li> <li>Simplicity and Debugging: A major advantage is the simplicity of construction and debugging. Since each layer only uses the layers below it, the first layer can be debugged without concern for the rest of the system.</li> <li>Disadvantages:<ul> <li>Difficulty of Definition: It is challenging to appropriately define the various layers.</li> <li>Efficiency: This structure tends to be less efficient than other implementations because each layer adds overhead to system execution.</li> </ul> </li> </ul>"},{"location":"#monolithic-structure","title":"Monolithic Structure","text":"<p>The monolithic approach is the most common and simplest organization for an operating system.</p> <ul> <li>Kernel as One Large Program: The entire operating system runs as a single, large program in kernel mode.</li> <li>Shared Functionality: Functionality of the OS is activated with simple function calls within the kernel.</li> <li>Drivers: Device drivers are loaded directly into the running kernel and become an integral part of it.</li> <li>Performance: Because there is very little overhead in the communication between modules within the kernel, monolithic systems are often very fast.</li> <li>Components: A monolithic kernel typically manages processes, memory, files, and the device management infrastructure all within a single address space.</li> </ul>"},{"location":"#7-microkernel-operating-systems","title":"7. Microkernel Operating Systems","text":"<p>The microkernel approach structures the operating system by removing all non-essential components from the kernel.</p>"},{"location":"#minimal-kernel-and-user-level-programs","title":"Minimal Kernel and User-Level Programs","text":"<ul> <li>Core Functionality: The microkernel offers only minimal process management, memory management, and a communications facility.</li> <li>External Services: All unnecessary parts of the kernel are removed and implemented instead as system-level and user-level programs.</li> <li>Operating Environment: These external services run in user mode rather than kernel mode.</li> </ul>"},{"location":"#message-passing-communication","title":"Message Passing Communication","text":"<ul> <li>Interaction Mechanism: Because the components are separated, communication between them is performed via message passing.</li> <li>Overhead: A significant disadvantage of this approach is poor performance caused by the increased system overhead required for message passing.</li> </ul>"},{"location":"#extensibility-and-reliability","title":"Extensibility and Reliability","text":"<ul> <li>Advantages:<ul> <li>Extensibility: The operating system can be easily extended since new services can be added as user-level programs without modifying the kernel.</li> <li>Kernel Maintenance: The kernel remains smaller, which means very few changes are required within it during updates.</li> <li>Security and Reliability: This structure offers more security and reliability because most services run in user space; if a service fails, it does not crash the entire kernel.</li> </ul> </li> </ul>"},{"location":"#8-concept-of-virtual-machine","title":"8. Concept of Virtual Machine","text":"<p>A Virtual Machine (VM) is a powerful concept in system architecture that allows for the creation of isolated execution environments on a single physical computer.</p>"},{"location":"#hardware-abstraction-and-illusion-of-multiple-environments","title":"Hardware Abstraction and Illusion of Multiple Environments","text":"<ul> <li>Hardware Abstraction: A virtual machine abstracts the physical hardware of a single computer, including the CPU, Memory, Disk drives, and Network Interface Cards.</li> <li>Creation of Illusion: It creates the illusion that each separate execution environment is running its own dedicated PC or environment.</li> <li>Execution Environments: This abstraction allows for several different execution environments to exist simultaneously on the same hardware.</li> </ul>"},{"location":"#host-and-guest-relationship","title":"Host and Guest Relationship","text":"<ul> <li>Guest Machine: The Virtual Machine itself is often referred to as a \"guest machine\".</li> <li>Host Environment: The guest machine is created within another computing environment known as the \"host\".</li> <li>Resource Scaling: Multiple virtual machines can be present and operational within a single host at one time.</li> </ul>"},{"location":"test/","title":"Hello","text":"<p>This is a test file.</p>"}]}